-- 제약조건 -> 컬럼에 원치않는 데이터가 입력,삭제, 수정되는걸 방지하게 만든 조건
-- Primary Key -> 테이블 고유 키
-- Unique -> 중복 X null O
-- Not Null -> 널값 안됨
-- Foreign Key -> 참조하는 테이블의 PK를 넣어놓은 컬럼, 중복/null 가능
-- Check -> 컬럼에 대한 데이터 제한

-- 제약조건을 확인하는 명령문 or 마우스로 확인
SELECT * FROM USER_CONSTRAINTS;
DROP TABLE DEPT22;
CREATE TABLE DEPT22 (
    dept_NO number(2)       CONSTRAINT DEPT2_DEPT_NO_PK Primary KEY,
    dept_name VARCHAR2(30)  CONSTRAINT DEPT2_DEPT_NAME_NN NOT NULL,
    DEPT_DATE DATE          DEFAULT SYSDATE, --> 아무것도 값 들어가지 않았을때 지정되는 값
    DEPT_PHONE VARCHAR2(30) CONSTRAINT DEPT2_DEPT_PHONE_UK Unique,
    DEPT_GENDER CHAR(1)     CONSTRAINT DEPT2_DEPT_GENDER_CK CHECK(DEPT_GENDER IN ('F','M')), --> WHERE 절에 해당
    LOCA_ID NUMBER(4)       CONSTRAINT DEPT2_LOCA_ID_FK REFERENCES LOCATIONS(LOCATION_ID)
);
DESC LOCATIONS;

--------------  이렇게 만들어도 만들어지긴 함 대신 이름이 SYSㅁㅁㅁㅁ 으로 만들어짐짐
DROP TABLE DEPTS22;
SELECT * FROM USER_CONSTRAINTS;
DROP TABLE DEPT22;
CREATE TABLE DEPT22 (
    dept_NO number(2)       Primary KEY,
    dept_name VARCHAR2(30)  NOT NULL,
    DEPT_DATE DATE          DEFAULT SYSDATE, --> 아무것도 값 들어가지 않았을때 지정되는 값
    DEPT_PHONE VARCHAR2(30) Unique,
    DEPT_GENDER CHAR(1)     CHECK(DEPT_GENDER IN ('F','M')), --> WHERE 절에 해당
    LOCA_ID NUMBER(4)       REFERENCES LOCATIONS(LOCATION_ID)
);

DESC DEPT22;

INSERT INTO DEPT22(DEPT_NO,DEPT_NAME,DEPT_PHONE,DEPT_GENDER,LOCA_ID)
VALUES (1,NULL,'010...','F',1700); -- NOT NULL 위배

INSERT INTO DEPT22(DEPT_NO,DEPT_NAME,DEPT_PHONE,DEPT_GENDER,LOCA_ID)
VALUES (1,'HONG','010...','X',1700); -- CHECK 제약 위배

INSERT INTO DEPT22(DEPT_NO,DEPT_NAME,DEPT_PHONE,DEPT_GENDER,LOCA_ID)
VALUES (1,'HONG','010...','F',100); -- FK 제약 위배

INSERT INTO DEPT22(DEPT_NO,DEPT_NAME,DEPT_PHONE,DEPT_GENDER,LOCA_ID)
VALUES (1,'HONG','010...','F',1700); 

INSERT INTO DEPT22(DEPT_NO,DEPT_NAME,DEPT_PHONE,DEPT_GENDER,LOCA_ID)
VALUES (2,'HONG','010...','F',1700); -- FK 제약 위배


------------------------------- 테이블 레벨 제약


DROP TABLE DEPTS;

CREATE TABLE DEPTS (
    dept_NO number(2),
    dept_name VARCHAR2(30) NOT NULL,  
    DEPT_DATE DATE   DEFAULT SYSDATE,
    DEPT_PHONE VARCHAR2(30), 
    DEPT_GENDER CHAR(1)     ,
    LOCA_ID NUMBER(4)   ,
    CONSTRAINT DEPTS_DEPT_NO_PN PRIMARY KEY(DEPT_NO/*,dept_name*/), --> 수퍼키 지정하고 싶다면 이렇게 변경
    CONSTRAINT DEPTS_PHONE_UK UNIQUE (DEPT_PHONE),
    CONSTRAINT DEPTS_GENDER_CK CHECK (DEPT_GENDER IN('F','M')),
    CONSTRAINT DEPTS_LOCA_ID_FK FOREIGN KEY (LOCA_ID) REFERENCES LOCATIONS(LOCATION_ID)
);

DESC DEPTS;



CREATE TABLE DEPTS (
    dept_NO number(2),
    dept_name VARCHAR2(30) NOT NULL,  
    DEPT_DATE DATE   DEFAULT SYSDATE,
    DEPT_PHONE VARCHAR2(30), 
    DEPT_GENDER CHAR(1)     ,
    LOCA_ID NUMBER(4)   
);

ALTER TABLE DEPTS ADD CONSTRAINT DEPT_NO_PK PRIMARY KEY (DEPT_NO); --> PK 추가
ALTER TABLE DEPTS MODIFY DEPT_NAME VARCHAR(30) NOT NULL; -- NOT NULL은 모디파이 구문으로 열 변경으로 추가
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_PHONE_UK UNIQUE (DEPT_PHONE);
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_GENDER_CK CEHCK (DEPT_GENDER IN ('F','N')); --> CK추가
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_LOCA_ID_FK FOREIGN KEY (LOCA_ID) REFERENCES LOCATIONS(LOCATION_ID); --> FK추가

-- 기본키(PK) 추가
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_NO_PK PRIMARY KEY (DEPT_NO);

-- NOT NULL 제약조건 추가
ALTER TABLE DEPTS MODIFY DEPT_NAME VARCHAR2(30) NOT NULL;

-- UNIQUE 제약조건 추가
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_PHONE_UK UNIQUE (DEPT_PHONE);

-- CHECK 제약조건 추가 (오타 수정: CEHCK → CHECK)
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_GENDER_CK CHECK (DEPT_GENDER IN ('F','M'));

-- 외래키(FK) 제약조건 추가
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_LOCA_ID_FK FOREIGN KEY (LOCA_ID) 
    REFERENCES LOCATIONS(LOCATION_ID);


--제약조건 삭제

ALTER TABLE DEPTS DROP PRIMARY KEY; -- 이렇게 지울 수 있음
ALTER TABLE DEPTS DROP CONSTRAINT DEPT_LOCA_ID_FK; -- 이름으로도 지울수 있음


-- 특정 테이블의 제약조건만 조회
SELECT * FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = '테이블명';

CREATE TABLE mem (
    M_NAME VARCHAR2(20) NOT NULL,
    M_NUM NUMBER(5)Primary KEY,
    REG_DATE DATE   NOT NULL, CONSTRAINT mem_regdate_uk Unique,
    SALARY NUMBER(10) CHECK (SALARY>0),
    LOCA NUMBER(4) CONSTRAINT mem_loca_loc_locid_fk REFERENCES LOCATIONS(LOCATION_ID)
);

CREATE TABLE mem (
    M_NAME VARCHAR2(20) NOT NULL,
    M_NUM NUMBER(5) CONSTRAINT mem_memnum_pk PRIMARY KEY,        
    REG_DATE DATE   NOT NULL CONSTRAINT mem_regdate_uk UNIQUE,  
    SALARY NUMBER(10) CONSTRAINT MEM_SAL_CHECK CHECK (SALARY>0),  
    LOCA NUMBER(4) CONSTRAINT mem_loca_loc_locid_fk REFERENCES LOCATIONS(LOCATION_ID)
);

INSERT INTO MEM
VALUES ('AAA',1,TO_DATE('2018-07-01','YYYY-MM-DD'),5000,1800);

INSERT INTO MEM
VALUES ('BBB',2,TO_DATE('2018-07-02','YYYY-MM-DD'),3000,1900);

INSERT INTO MEM
VALUES ('CCC',3,TO_DATE('2018-07-03','YYYY-MM-DD'),3000,2000);

INSERT INTO MEM
VALUES ('DDD',4,SYSDATE,2000,1800);

SELECT * FROM MEM;


-- 문제2.
-- 도서테이블, 도서 대여 이력 테이블을 생성하려 합니다.
-- 도서 테이블은
-- 도서번호(문자) PK, 도서명(문자), 출판사(문자), 입고일(날짜)

CREATE TABLE BOOKS(
    BOOK_NUM VARCHAR2(30) PRIMARY KEY,
    BOOK_NAME VARCHAR2(30),
    BOOK_PUBLISHER VARCHAR2(30),
    BOOK_BOUGHT DATE
);
-- 도서 대여 이력 테이블은
-- 대여번호(숫자) PK, 도서번호(문자) FK, 대여일(날짜), 반납일(날짜), 반납여부(Y/N)

CREATE TABLE BORROWBOOK(
    BOOK_BORROW_NUM NUMBER(10) PRIMARY KEY,
    BOOK_NUM VARCHAR2(30) CONSTRAINT BORROWBOOK_BOOKNUM REFERENCES BOOKS(BOOK_NUM),
    BOOK_DATE_BORROW DATE,
    BOOK_DATE_RETURN DATE,
    BOOK_CHECK_RETURNED CHAR(1) CONSTRAINT BOOK_CHECK_RETURNED_CHECK CHECK (BOOK_CHECK_RETURNED IN('Y','N'))
);
-- 를 가집니다.
-- 적절한 테이블을 생성해 보세요.

SELECT * FROM BOOKS;
SELECT * FROM BORROWBOOK;

